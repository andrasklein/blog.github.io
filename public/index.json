[{"content":"This is the section that I am going to sentence to finding CVE-s.\n","permalink":"//localhost:1313/posts/third/","summary":"\u003cp\u003eThis is the section that I am going to sentence to finding CVE-s.\u003c/p\u003e","title":"Finding CVE-s"},{"content":"As I earned my Practical Network Penetration Tester (PNPT) certification from TCM Security, I wanted to further advance and improve my knowledge. My new goal became the OSCP certification. As I engaged with industry professionals across my country, I learned that this certification had become the standard. As I love new challenges I started to dig deep into what resources should I utilize and where should I begin.\nAlthough I started the CPTS learning path at HTB Academy I needed an additional home lab where I could practice everything I learned and is going to hold a stronghold for all my attacks and strategies. I decided to set up the Game of Active Directory (GOAD) as it is going to be just an awesome playground to practice my skills.\nThe author of this lab is Mayfly who was kind enough to make this lab publicly accessible and provide amazing documentation as I set up the lab. (I am going to link Mayfly\u0026rsquo;s documentation at the end of the resources section) There are many ways to set up this home lab and I even found an amazing video from Conda that showcased how an individual can easily deploy this. (I am going to link the video to the resources section)\nThe bare minimum hardware requirements for the version I was setting up were 24GB of RAM and 120GB of storage.\nBefore I begin I would like to express that so many write-ups are edited in a way that everything works just right out of the box. But I believe that there are just other things behind the curtain that do not get enough attention. I had to troubleshoot a lot of things to meet the requirements to build the lab and I just learned so much during that process that\u0026rsquo;s why I am going to include it in my write-up, because it also helped me improve.\nI am going to split my write-up into two sections, one of them is going to focus on how I troubleshoot my problems along the way as I know it can be beneficial for later. The other section is going to focus on the commands and steps I did to set up the home lab.\nThe problems I faced during the setup (as I followed the steps during the setup video):\nAs the lab is intended to be installed from a Linux host and was tested only on this for the documentation. The wise step was to use nested virtualization this way the lab can be set up within a VM.\nAs I use VMware nested virtualization was not of an easy step because I needed to reproduce the following steps to make it work.\nHad to turn these off.\nAlso had to turn off memory integrity.\nAfter these steps, I was able to start my VMware host Linux machine with the following setting, which enabled nested virtualization:\nI set up a dedicated VM for this task and decided to use a separate installer image. With a new set, I installed VirtualBox with the following command.\nsudo apt install virtualbox -y But this was not enough, on a newly installed .iso image you need to install the kernel modules.\nYou can check the status with the following command:\nsudo service virtualbox status You can check the kernel modules with the following command:\nuname -r And after this command, I needed to download the right ones:\nsudo apt install linux-headers |kernelmodules| A possible workaround would be to install a pre-built virtual machine and after installing VirtualBox it is going to work right out of the box.\nAlso, I ran into the problem that I did not have enough storage dedicated to the VM and I found a tool named GParted to be most efficient to resolve this issue.\nAfter resolving all my upcoming issues I used to follow a chain of steps to set up the lab:\nsudo apt install virtualbox -y sudo apt install vagrant I also went with the docker installation method as it seemed like the fastest and easiest.\nsudo apt install docker.io -y vagrant plugin install vagrant-reload gem install winrm winrm-fs winrm-elevated After installing all these requirements I installed the GitHub directory related to the project.\ngit clone https://github.com/Orange-Cyberdefense/GOAD.git I changed my directory to GOAD and ran a check script to make sure I was ready to go and install.\n./goad.sh -t check -l GOAD -p virtualbox -m docker After a successful affirmation, I can run the install script as well.\n./goad.sh -t install -l GOAD -p virtualbox -m docker This was going to run for a few hours but after that, I was good to go. It is important to note that the labs can be started with the following command:\n./goad.sh -t start -p virtualbox -l GOAD -m docker Resources:\nVideo I used for the setup:\nhttps://www.youtube.com/watch?v=fXausmYcObE The GitHub page I also used along my setup:\nhttps://github.com/Orange-Cyberdefense/GOAD The specific documentation I used:\nhttps://github.com/Orange-Cyberdefense/GOAD/blob/main/docs/install_with_virtualbox.md If you notice mistakes or typos or you just have suggestions I would love to hear your feedback and improve at the same time.\n","permalink":"//localhost:1313/posts/first/","summary":"\u003cp\u003eAs I earned my Practical Network Penetration Tester (PNPT) certification from TCM Security, I wanted to further advance and improve my knowledge. My new goal became the OSCP certification. As I engaged with industry professionals across my country, I learned that this certification had become the standard. As I love new challenges I started to dig deep into what resources should I utilize and where should I begin.\u003c/p\u003e\n\u003cp\u003eAlthough I started the CPTS learning path at HTB Academy I needed an additional home lab where I could practice everything I learned and is going to hold a stronghold for all my attacks and strategies. I decided to set up the Game of Active Directory (GOAD) as it is going to be just an awesome playground to practice my skills.\u003c/p\u003e","title":"AD home lab"},{"content":"I have found myself in this situation many times along my journey on HTB and THM machines, I needed a port scanner that was easy to transfer to a target machine and use from that point utilizing available technologies.\nOriginal author credits go to Heath Adams. My tool is based heavily on what I learned from TCM Academy in the PEH course.\nThis is what was used in the PEH course.\nimport sys import socket from datetime import datetime if len(sys.argv) == 2: target = socket.gethostbyname(sys.argv[1]) else: print(\u0026#34;Invalid amount of arguments.\u0026#34;) print(\u0026#34;Syntax: python3 scanner.py\u0026#34;) print(\u0026#34;-\u0026#34; * 50) print(\u0026#34;Scanning target \u0026#34;+target) print(\u0026#34;Time started: \u0026#34;+str(datetime.now())) print(\u0026#34;-\u0026#34; * 50) try: for port in range(50,85): s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) socket.setdefaulttimeout(1) result = s.connect_ex((target,port)) if result == 0: print(\u0026#34;Port {} is open\u0026#34;.format(port)) s.close() except KeyboardInterrupt: print(\u0026#34;\\nExiting program.\u0026#34;) sys.exit() except socket.gaierror: print(\u0026#34;Hostname could not be resolved.\u0026#34;) sys.exit() except socket.error: print(\u0026#34;Could not connect to server.\u0026#34;) sys.exit() Here are the changes I made to it:\nI added the \u0026ldquo;argparse\u0026rdquo; library to have the freedom to have a greater syntax when executing the code.\nimport argparse It allows the user to specify with the -p and -i what IP address and port the user wants to scan for.\nI added the \u0026ldquo;threading\u0026rdquo; Python module which allows to have separate operations by creating so-called threads. Why is it important? Because with threading a user can scan multiple ports at the same time so it speeds up the scan.\nimport threading I also created functions for more robust solutions and defined the following things in the scan_port function:\nsetting up a timeout s.settimeout(1) This makes it possible to prevent the program from hanging if a port is closed or there are any other issues. This makes it possible to move on to the next port if needed.\nchecking for open port result = s.connect_ex((target, port)) This is the core function. What does it do? It attempts to connect to the specified IP on the specified port(s).\ngrabbing the banner if result == 0: try: banner = s.recv(1024).decode().strip() print(f\u0026#34;Port {port} is open | Service: {banner}\u0026#34;) except: print(f\u0026#34;Port {port} is open | Service: Unknown\u0026#34;) This part helps to understand what service is behind the currently scanned port.\nhandling errors except socket.error: print(f\u0026#34;Could not connect to port {port}\u0026#34;) except Exception as e: print(f\u0026#34;Error scanning port {port}: {e}\u0026#34;) This way the scanner can easily handle issues.\nI added the run_scan function and defined the following things:\nbanner for the output print(\u0026#34;-\u0026#34; * 50) print(f\u0026#34;Scanning target {target}\u0026#34;) print(\u0026#34;Time started: \u0026#34; + str(datetime.now())) print(\u0026#34;-\u0026#34; * 50) This prints out a banner to the console and also provides the user with feedback.\nutilized the previously imported threading module threads = [] for port in port_range: thread = threading.Thread(target=scan_port, args=(target, port)) threads.append(thread) thread.start() For each port, it creates a thread that will execute the function that it belongs to.\noutput the finished scan print(\u0026#34;-\u0026#34; * 50) print(\u0026#34;Scanning complete.\u0026#34;) print(f\u0026#34;Time finished: {str(datetime.now())}\u0026#34;) This provides feedback about the scan\u0026rsquo;s completion and duration.\nThe last part of the code defines the following things:\nwhich argument should do wath parser = argparse.ArgumentParser(description=\u0026#34;A simple multi-threaded port scanner.\u0026#34;) parser.add_argument(\u0026#39;-i\u0026#39;, \u0026#39;--ip\u0026#39;, type=str, required=True, help=\u0026#39;Target IP address\u0026#39;) parser.add_argument(\u0026#39;-p\u0026#39;, \u0026#39;--ports\u0026#39;, type=str, required=True, help=\u0026#39;Port range to scan (e.g., 20-80)\u0026#39;) This allows the user of the script to specify which IP address and port range they want to scan.\nstore user input in a variable args = parser.parse_args() This variable named args stores what the user inputs into the command line. This variable is used later in other processes.\nprocessing the port range port_range = args.ports.split(\u0026#39;-\u0026#39;) start_port = int(port_range[0]) end_port = int(port_range[1]) port_range = range(start_port, end_port + 1) This way the script can split the range into a start and an end value. Also allows the script can easily manage and iterate over the specified port range.\nhandling different types of errors try: run_scan(target, port_range) except KeyboardInterrupt: print(\u0026#34;\\nExiting program.\u0026#34;) sys.exit() except socket.gaierror: print(\u0026#34;Hostname could not be resolved.\u0026#34;) sys.exit() except socket.error: print(\u0026#34;Could not connect to server.\u0026#34;) sys.exit() This section ensures that the script can respond correctly to issues that could happen. For example issues like interruption by a user or network problems.\nThe final script:\n#!/bin/python3 import sys import socket from datetime import datetime import threading import argparse def scan_port(target, port): try: s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.settimeout(1) result = s.connect_ex((target, port)) if result == 0: try: banner = s.recv(1024).decode().strip() print(f\u0026#34;Port {port} is open | Service: {banner}\u0026#34;) except: print(f\u0026#34;Port {port} is open | Service: Unknown\u0026#34;) s.close() except socket.error: print(f\u0026#34;Could not connect to port {port}\u0026#34;) except Exception as e: print(f\u0026#34;Error scanning port {port}: {e}\u0026#34;) def run_scan(target, port_range): print(\u0026#34;-\u0026#34; * 50) print(f\u0026#34;Scanning target {target}\u0026#34;) print(\u0026#34;Time started: \u0026#34; + str(datetime.now())) print(\u0026#34;-\u0026#34; * 50) threads = [] for port in port_range: thread = threading.Thread(target=scan_port, args=(target, port)) threads.append(thread) thread.start() for thread in threads: thread.join() print(\u0026#34;-\u0026#34; * 50) print(\u0026#34;Scanning complete.\u0026#34;) print(f\u0026#34;Time finished: {str(datetime.now())}\u0026#34;) parser = argparse.ArgumentParser(description=\u0026#34;A simple multi-threaded port scanner.\u0026#34;) parser.add_argument(\u0026#39;-i\u0026#39;, \u0026#39;--ip\u0026#39;, type=str, required=True, help=\u0026#39;Target IP address\u0026#39;) parser.add_argument(\u0026#39;-p\u0026#39;, \u0026#39;--ports\u0026#39;, type=str, required=True, help=\u0026#39;Port range to scan (e.g., 20-80)\u0026#39;) args = parser.parse_args() target = socket.gethostbyname(args.ip) port_range = args.ports.split(\u0026#39;-\u0026#39;) start_port = int(port_range[0]) end_port = int(port_range[1]) port_range = range(start_port, end_port + 1) try: run_scan(target, port_range) except KeyboardInterrupt: print(\u0026#34;\\nExiting program.\u0026#34;) sys.exit() except socket.gaierror: print(\u0026#34;Hostname could not be resolved.\u0026#34;) sys.exit() except socket.error: print(\u0026#34;Could not connect to server.\u0026#34;) sys.exit() If you notice mistakes or typos or you just have suggestions I would love to hear your feedback and improve at the same time.\n","permalink":"//localhost:1313/posts/second/","summary":"\u003cp\u003eI have found myself in this situation many times along my journey on HTB and THM machines, I needed a port scanner that was easy to transfer to a target machine and use from that point utilizing available technologies.\u003c/p\u003e\n\u003cp\u003eOriginal author credits go to Heath Adams. My tool is based heavily on what I learned from TCM Academy in the PEH course.\u003c/p\u003e\n\u003cp\u003eThis is what was used in the PEH course.\u003c/p\u003e","title":"Building a port scanner in Python"},{"content":"I started this blog to share how I learn and improve constantly every day and also to make a portfolio about the things that keep me interested.\nI am currently a student in Hungary who studies Business Informatics and as much as I love math and data analysis I have a much greater passion for ethical hacking and computer networking.\nThroughout my development, I have been driven by curiosity and a desire to get a better understanding of how things work. I also enjoy building home labs where I can study and practice anything that I learn along my journey. Thank you for reading and thank you for visiting my blog!\n","permalink":"//localhost:1313/about/","summary":"about","title":"About"}]